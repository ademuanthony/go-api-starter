// Code generated by SQLBoiler 4.7.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Account is an object representing the database table.
type Account struct {
	ID                 string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	ReferralCode       string      `boil:"referral_code" json:"referral_code" toml:"referral_code" yaml:"referral_code"`
	Username           string      `boil:"username" json:"username" toml:"username" yaml:"username"`
	Password           string      `boil:"password" json:"password" toml:"password" yaml:"password"`
	Email              string      `boil:"email" json:"email" toml:"email" yaml:"email"`
	PhoneNumber        string      `boil:"phone_number" json:"phone_number" toml:"phone_number" yaml:"phone_number"`
	CreatedAt          int64       `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	FirstName          string      `boil:"first_name" json:"first_name" toml:"first_name" yaml:"first_name"`
	LastName           string      `boil:"last_name" json:"last_name" toml:"last_name" yaml:"last_name"`
	ReferralID         null.String `boil:"referral_id" json:"referral_id,omitempty" toml:"referral_id" yaml:"referral_id,omitempty"`
	ReferralID2        null.String `boil:"referral_id_2" json:"referral_id_2,omitempty" toml:"referral_id_2" yaml:"referral_id_2,omitempty"`
	ReferralID3        null.String `boil:"referral_id_3" json:"referral_id_3,omitempty" toml:"referral_id_3" yaml:"referral_id_3,omitempty"`
	WithdrawalAddresss string      `boil:"withdrawal_addresss" json:"withdrawal_addresss" toml:"withdrawal_addresss" yaml:"withdrawal_addresss"`
	Balance            int64       `boil:"balance" json:"balance" toml:"balance" yaml:"balance"`
	Principal          int64       `boil:"principal" json:"principal" toml:"principal" yaml:"principal"`
	MaturedPrincipal   int64       `boil:"matured_principal" json:"matured_principal" toml:"matured_principal" yaml:"matured_principal"`
	Role               int         `boil:"role" json:"role" toml:"role" yaml:"role"`
	Points             int64       `boil:"points" json:"points" toml:"points" yaml:"points"`
	Bonus              int64       `boil:"bonus" json:"bonus" toml:"bonus" yaml:"bonus"`
	StableNaira        int64       `boil:"stable_naira" json:"stable_naira" toml:"stable_naira" yaml:"stable_naira"`

	R *accountR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L accountL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AccountColumns = struct {
	ID                 string
	ReferralCode       string
	Username           string
	Password           string
	Email              string
	PhoneNumber        string
	CreatedAt          string
	FirstName          string
	LastName           string
	ReferralID         string
	ReferralID2        string
	ReferralID3        string
	WithdrawalAddresss string
	Balance            string
	Principal          string
	MaturedPrincipal   string
	Role               string
	Points             string
	Bonus              string
	StableNaira        string
}{
	ID:                 "id",
	ReferralCode:       "referral_code",
	Username:           "username",
	Password:           "password",
	Email:              "email",
	PhoneNumber:        "phone_number",
	CreatedAt:          "created_at",
	FirstName:          "first_name",
	LastName:           "last_name",
	ReferralID:         "referral_id",
	ReferralID2:        "referral_id_2",
	ReferralID3:        "referral_id_3",
	WithdrawalAddresss: "withdrawal_addresss",
	Balance:            "balance",
	Principal:          "principal",
	MaturedPrincipal:   "matured_principal",
	Role:               "role",
	Points:             "points",
	Bonus:              "bonus",
	StableNaira:        "stable_naira",
}

var AccountTableColumns = struct {
	ID                 string
	ReferralCode       string
	Username           string
	Password           string
	Email              string
	PhoneNumber        string
	CreatedAt          string
	FirstName          string
	LastName           string
	ReferralID         string
	ReferralID2        string
	ReferralID3        string
	WithdrawalAddresss string
	Balance            string
	Principal          string
	MaturedPrincipal   string
	Role               string
	Points             string
	Bonus              string
	StableNaira        string
}{
	ID:                 "account.id",
	ReferralCode:       "account.referral_code",
	Username:           "account.username",
	Password:           "account.password",
	Email:              "account.email",
	PhoneNumber:        "account.phone_number",
	CreatedAt:          "account.created_at",
	FirstName:          "account.first_name",
	LastName:           "account.last_name",
	ReferralID:         "account.referral_id",
	ReferralID2:        "account.referral_id_2",
	ReferralID3:        "account.referral_id_3",
	WithdrawalAddresss: "account.withdrawal_addresss",
	Balance:            "account.balance",
	Principal:          "account.principal",
	MaturedPrincipal:   "account.matured_principal",
	Role:               "account.role",
	Points:             "account.points",
	Bonus:              "account.bonus",
	StableNaira:        "account.stable_naira",
}

// Generated where

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperstring) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

var AccountWhere = struct {
	ID                 whereHelperstring
	ReferralCode       whereHelperstring
	Username           whereHelperstring
	Password           whereHelperstring
	Email              whereHelperstring
	PhoneNumber        whereHelperstring
	CreatedAt          whereHelperint64
	FirstName          whereHelperstring
	LastName           whereHelperstring
	ReferralID         whereHelpernull_String
	ReferralID2        whereHelpernull_String
	ReferralID3        whereHelpernull_String
	WithdrawalAddresss whereHelperstring
	Balance            whereHelperint64
	Principal          whereHelperint64
	MaturedPrincipal   whereHelperint64
	Role               whereHelperint
	Points             whereHelperint64
	Bonus              whereHelperint64
	StableNaira        whereHelperint64
}{
	ID:                 whereHelperstring{field: "\"account\".\"id\""},
	ReferralCode:       whereHelperstring{field: "\"account\".\"referral_code\""},
	Username:           whereHelperstring{field: "\"account\".\"username\""},
	Password:           whereHelperstring{field: "\"account\".\"password\""},
	Email:              whereHelperstring{field: "\"account\".\"email\""},
	PhoneNumber:        whereHelperstring{field: "\"account\".\"phone_number\""},
	CreatedAt:          whereHelperint64{field: "\"account\".\"created_at\""},
	FirstName:          whereHelperstring{field: "\"account\".\"first_name\""},
	LastName:           whereHelperstring{field: "\"account\".\"last_name\""},
	ReferralID:         whereHelpernull_String{field: "\"account\".\"referral_id\""},
	ReferralID2:        whereHelpernull_String{field: "\"account\".\"referral_id_2\""},
	ReferralID3:        whereHelpernull_String{field: "\"account\".\"referral_id_3\""},
	WithdrawalAddresss: whereHelperstring{field: "\"account\".\"withdrawal_addresss\""},
	Balance:            whereHelperint64{field: "\"account\".\"balance\""},
	Principal:          whereHelperint64{field: "\"account\".\"principal\""},
	MaturedPrincipal:   whereHelperint64{field: "\"account\".\"matured_principal\""},
	Role:               whereHelperint{field: "\"account\".\"role\""},
	Points:             whereHelperint64{field: "\"account\".\"points\""},
	Bonus:              whereHelperint64{field: "\"account\".\"bonus\""},
	StableNaira:        whereHelperint64{field: "\"account\".\"stable_naira\""},
}

// AccountRels is where relationship names are stored.
var AccountRels = struct {
	AccountTransactions        string
	Beneficiaries              string
	CryptoAssets               string
	CryptoDeposits             string
	DailyEarnings              string
	Deposits                   string
	DepositWallets             string
	Investments                string
	LoginInfos                 string
	Notifications              string
	PaymentLinks               string
	ReferralPayouts            string
	FromAccountReferralPayouts string
	SecurityCodes              string
	StableNairaTransactions    string
	Subscriptions              string
	Trades                     string
	TradeSchedules             string
	ReceiverTransfers          string
	SenderTransfers            string
	UserSettings               string
	Wallets                    string
	Withdrawals                string
}{
	AccountTransactions:        "AccountTransactions",
	Beneficiaries:              "Beneficiaries",
	CryptoAssets:               "CryptoAssets",
	CryptoDeposits:             "CryptoDeposits",
	DailyEarnings:              "DailyEarnings",
	Deposits:                   "Deposits",
	DepositWallets:             "DepositWallets",
	Investments:                "Investments",
	LoginInfos:                 "LoginInfos",
	Notifications:              "Notifications",
	PaymentLinks:               "PaymentLinks",
	ReferralPayouts:            "ReferralPayouts",
	FromAccountReferralPayouts: "FromAccountReferralPayouts",
	SecurityCodes:              "SecurityCodes",
	StableNairaTransactions:    "StableNairaTransactions",
	Subscriptions:              "Subscriptions",
	Trades:                     "Trades",
	TradeSchedules:             "TradeSchedules",
	ReceiverTransfers:          "ReceiverTransfers",
	SenderTransfers:            "SenderTransfers",
	UserSettings:               "UserSettings",
	Wallets:                    "Wallets",
	Withdrawals:                "Withdrawals",
}

// accountR is where relationships are stored.
type accountR struct {
	AccountTransactions        AccountTransactionSlice     `boil:"AccountTransactions" json:"AccountTransactions" toml:"AccountTransactions" yaml:"AccountTransactions"`
	Beneficiaries              BeneficiarySlice            `boil:"Beneficiaries" json:"Beneficiaries" toml:"Beneficiaries" yaml:"Beneficiaries"`
	CryptoAssets               CryptoAssetSlice            `boil:"CryptoAssets" json:"CryptoAssets" toml:"CryptoAssets" yaml:"CryptoAssets"`
	CryptoDeposits             CryptoDepositSlice          `boil:"CryptoDeposits" json:"CryptoDeposits" toml:"CryptoDeposits" yaml:"CryptoDeposits"`
	DailyEarnings              DailyEarningSlice           `boil:"DailyEarnings" json:"DailyEarnings" toml:"DailyEarnings" yaml:"DailyEarnings"`
	Deposits                   DepositSlice                `boil:"Deposits" json:"Deposits" toml:"Deposits" yaml:"Deposits"`
	DepositWallets             DepositWalletSlice          `boil:"DepositWallets" json:"DepositWallets" toml:"DepositWallets" yaml:"DepositWallets"`
	Investments                InvestmentSlice             `boil:"Investments" json:"Investments" toml:"Investments" yaml:"Investments"`
	LoginInfos                 LoginInfoSlice              `boil:"LoginInfos" json:"LoginInfos" toml:"LoginInfos" yaml:"LoginInfos"`
	Notifications              NotificationSlice           `boil:"Notifications" json:"Notifications" toml:"Notifications" yaml:"Notifications"`
	PaymentLinks               PaymentLinkSlice            `boil:"PaymentLinks" json:"PaymentLinks" toml:"PaymentLinks" yaml:"PaymentLinks"`
	ReferralPayouts            ReferralPayoutSlice         `boil:"ReferralPayouts" json:"ReferralPayouts" toml:"ReferralPayouts" yaml:"ReferralPayouts"`
	FromAccountReferralPayouts ReferralPayoutSlice         `boil:"FromAccountReferralPayouts" json:"FromAccountReferralPayouts" toml:"FromAccountReferralPayouts" yaml:"FromAccountReferralPayouts"`
	SecurityCodes              SecurityCodeSlice           `boil:"SecurityCodes" json:"SecurityCodes" toml:"SecurityCodes" yaml:"SecurityCodes"`
	StableNairaTransactions    StableNairaTransactionSlice `boil:"StableNairaTransactions" json:"StableNairaTransactions" toml:"StableNairaTransactions" yaml:"StableNairaTransactions"`
	Subscriptions              SubscriptionSlice           `boil:"Subscriptions" json:"Subscriptions" toml:"Subscriptions" yaml:"Subscriptions"`
	Trades                     TradeSlice                  `boil:"Trades" json:"Trades" toml:"Trades" yaml:"Trades"`
	TradeSchedules             TradeScheduleSlice          `boil:"TradeSchedules" json:"TradeSchedules" toml:"TradeSchedules" yaml:"TradeSchedules"`
	ReceiverTransfers          TransferSlice               `boil:"ReceiverTransfers" json:"ReceiverTransfers" toml:"ReceiverTransfers" yaml:"ReceiverTransfers"`
	SenderTransfers            TransferSlice               `boil:"SenderTransfers" json:"SenderTransfers" toml:"SenderTransfers" yaml:"SenderTransfers"`
	UserSettings               UserSettingSlice            `boil:"UserSettings" json:"UserSettings" toml:"UserSettings" yaml:"UserSettings"`
	Wallets                    WalletSlice                 `boil:"Wallets" json:"Wallets" toml:"Wallets" yaml:"Wallets"`
	Withdrawals                WithdrawalSlice             `boil:"Withdrawals" json:"Withdrawals" toml:"Withdrawals" yaml:"Withdrawals"`
}

// NewStruct creates a new relationship struct
func (*accountR) NewStruct() *accountR {
	return &accountR{}
}

// accountL is where Load methods for each relationship are stored.
type accountL struct{}

var (
	accountAllColumns            = []string{"id", "referral_code", "username", "password", "email", "phone_number", "created_at", "first_name", "last_name", "referral_id", "referral_id_2", "referral_id_3", "withdrawal_addresss", "balance", "principal", "matured_principal", "role", "points", "bonus", "stable_naira"}
	accountColumnsWithoutDefault = []string{"id", "referral_code", "username", "password", "email", "phone_number", "created_at"}
	accountColumnsWithDefault    = []string{"first_name", "last_name", "referral_id", "referral_id_2", "referral_id_3", "withdrawal_addresss", "balance", "principal", "matured_principal", "role", "points", "bonus", "stable_naira"}
	accountPrimaryKeyColumns     = []string{"id"}
)

type (
	// AccountSlice is an alias for a slice of pointers to Account.
	// This should almost always be used instead of []Account.
	AccountSlice []*Account

	accountQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	accountType                 = reflect.TypeOf(&Account{})
	accountMapping              = queries.MakeStructMapping(accountType)
	accountPrimaryKeyMapping, _ = queries.BindMapping(accountType, accountMapping, accountPrimaryKeyColumns)
	accountInsertCacheMut       sync.RWMutex
	accountInsertCache          = make(map[string]insertCache)
	accountUpdateCacheMut       sync.RWMutex
	accountUpdateCache          = make(map[string]updateCache)
	accountUpsertCacheMut       sync.RWMutex
	accountUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single account record from the query.
func (q accountQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Account, error) {
	o := &Account{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for account")
	}

	return o, nil
}

// All returns all Account records from the query.
func (q accountQuery) All(ctx context.Context, exec boil.ContextExecutor) (AccountSlice, error) {
	var o []*Account

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Account slice")
	}

	return o, nil
}

// Count returns the count of all Account records in the query.
func (q accountQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count account rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q accountQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if account exists")
	}

	return count > 0, nil
}

// AccountTransactions retrieves all the account_transaction's AccountTransactions with an executor.
func (o *Account) AccountTransactions(mods ...qm.QueryMod) accountTransactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"account_transaction\".\"account_id\"=?", o.ID),
	)

	query := AccountTransactions(queryMods...)
	queries.SetFrom(query.Query, "\"account_transaction\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"account_transaction\".*"})
	}

	return query
}

// Beneficiaries retrieves all the beneficiary's Beneficiaries with an executor.
func (o *Account) Beneficiaries(mods ...qm.QueryMod) beneficiaryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"beneficiary\".\"account_id\"=?", o.ID),
	)

	query := Beneficiaries(queryMods...)
	queries.SetFrom(query.Query, "\"beneficiary\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"beneficiary\".*"})
	}

	return query
}

// CryptoAssets retrieves all the crypto_asset's CryptoAssets with an executor.
func (o *Account) CryptoAssets(mods ...qm.QueryMod) cryptoAssetQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"crypto_asset\".\"account_id\"=?", o.ID),
	)

	query := CryptoAssets(queryMods...)
	queries.SetFrom(query.Query, "\"crypto_asset\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"crypto_asset\".*"})
	}

	return query
}

// CryptoDeposits retrieves all the crypto_deposit's CryptoDeposits with an executor.
func (o *Account) CryptoDeposits(mods ...qm.QueryMod) cryptoDepositQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"crypto_deposit\".\"account_id\"=?", o.ID),
	)

	query := CryptoDeposits(queryMods...)
	queries.SetFrom(query.Query, "\"crypto_deposit\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"crypto_deposit\".*"})
	}

	return query
}

// DailyEarnings retrieves all the daily_earning's DailyEarnings with an executor.
func (o *Account) DailyEarnings(mods ...qm.QueryMod) dailyEarningQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"daily_earning\".\"account_id\"=?", o.ID),
	)

	query := DailyEarnings(queryMods...)
	queries.SetFrom(query.Query, "\"daily_earning\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"daily_earning\".*"})
	}

	return query
}

// Deposits retrieves all the deposit's Deposits with an executor.
func (o *Account) Deposits(mods ...qm.QueryMod) depositQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"deposit\".\"account_id\"=?", o.ID),
	)

	query := Deposits(queryMods...)
	queries.SetFrom(query.Query, "\"deposit\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"deposit\".*"})
	}

	return query
}

// DepositWallets retrieves all the deposit_wallet's DepositWallets with an executor.
func (o *Account) DepositWallets(mods ...qm.QueryMod) depositWalletQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"deposit_wallet\".\"account_id\"=?", o.ID),
	)

	query := DepositWallets(queryMods...)
	queries.SetFrom(query.Query, "\"deposit_wallet\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"deposit_wallet\".*"})
	}

	return query
}

// Investments retrieves all the investment's Investments with an executor.
func (o *Account) Investments(mods ...qm.QueryMod) investmentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"investment\".\"account_id\"=?", o.ID),
	)

	query := Investments(queryMods...)
	queries.SetFrom(query.Query, "\"investment\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"investment\".*"})
	}

	return query
}

// LoginInfos retrieves all the login_info's LoginInfos with an executor.
func (o *Account) LoginInfos(mods ...qm.QueryMod) loginInfoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"login_info\".\"account_id\"=?", o.ID),
	)

	query := LoginInfos(queryMods...)
	queries.SetFrom(query.Query, "\"login_info\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"login_info\".*"})
	}

	return query
}

// Notifications retrieves all the notification's Notifications with an executor.
func (o *Account) Notifications(mods ...qm.QueryMod) notificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"notification\".\"account_id\"=?", o.ID),
	)

	query := Notifications(queryMods...)
	queries.SetFrom(query.Query, "\"notification\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"notification\".*"})
	}

	return query
}

// PaymentLinks retrieves all the payment_link's PaymentLinks with an executor.
func (o *Account) PaymentLinks(mods ...qm.QueryMod) paymentLinkQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"payment_link\".\"account_id\"=?", o.ID),
	)

	query := PaymentLinks(queryMods...)
	queries.SetFrom(query.Query, "\"payment_link\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"payment_link\".*"})
	}

	return query
}

// ReferralPayouts retrieves all the referral_payout's ReferralPayouts with an executor.
func (o *Account) ReferralPayouts(mods ...qm.QueryMod) referralPayoutQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"referral_payout\".\"account_id\"=?", o.ID),
	)

	query := ReferralPayouts(queryMods...)
	queries.SetFrom(query.Query, "\"referral_payout\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"referral_payout\".*"})
	}

	return query
}

// FromAccountReferralPayouts retrieves all the referral_payout's ReferralPayouts with an executor via from_account_id column.
func (o *Account) FromAccountReferralPayouts(mods ...qm.QueryMod) referralPayoutQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"referral_payout\".\"from_account_id\"=?", o.ID),
	)

	query := ReferralPayouts(queryMods...)
	queries.SetFrom(query.Query, "\"referral_payout\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"referral_payout\".*"})
	}

	return query
}

// SecurityCodes retrieves all the security_code's SecurityCodes with an executor.
func (o *Account) SecurityCodes(mods ...qm.QueryMod) securityCodeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"security_code\".\"account_id\"=?", o.ID),
	)

	query := SecurityCodes(queryMods...)
	queries.SetFrom(query.Query, "\"security_code\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"security_code\".*"})
	}

	return query
}

// StableNairaTransactions retrieves all the stable_naira_transaction's StableNairaTransactions with an executor.
func (o *Account) StableNairaTransactions(mods ...qm.QueryMod) stableNairaTransactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"stable_naira_transaction\".\"account_id\"=?", o.ID),
	)

	query := StableNairaTransactions(queryMods...)
	queries.SetFrom(query.Query, "\"stable_naira_transaction\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"stable_naira_transaction\".*"})
	}

	return query
}

// Subscriptions retrieves all the subscription's Subscriptions with an executor.
func (o *Account) Subscriptions(mods ...qm.QueryMod) subscriptionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"subscription\".\"account_id\"=?", o.ID),
	)

	query := Subscriptions(queryMods...)
	queries.SetFrom(query.Query, "\"subscription\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"subscription\".*"})
	}

	return query
}

// Trades retrieves all the trade's Trades with an executor.
func (o *Account) Trades(mods ...qm.QueryMod) tradeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"trade\".\"account_id\"=?", o.ID),
	)

	query := Trades(queryMods...)
	queries.SetFrom(query.Query, "\"trade\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"trade\".*"})
	}

	return query
}

// TradeSchedules retrieves all the trade_schedule's TradeSchedules with an executor.
func (o *Account) TradeSchedules(mods ...qm.QueryMod) tradeScheduleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"trade_schedule\".\"account_id\"=?", o.ID),
	)

	query := TradeSchedules(queryMods...)
	queries.SetFrom(query.Query, "\"trade_schedule\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"trade_schedule\".*"})
	}

	return query
}

// ReceiverTransfers retrieves all the transfer's Transfers with an executor via receiver_id column.
func (o *Account) ReceiverTransfers(mods ...qm.QueryMod) transferQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"transfer\".\"receiver_id\"=?", o.ID),
	)

	query := Transfers(queryMods...)
	queries.SetFrom(query.Query, "\"transfer\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"transfer\".*"})
	}

	return query
}

// SenderTransfers retrieves all the transfer's Transfers with an executor via sender_id column.
func (o *Account) SenderTransfers(mods ...qm.QueryMod) transferQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"transfer\".\"sender_id\"=?", o.ID),
	)

	query := Transfers(queryMods...)
	queries.SetFrom(query.Query, "\"transfer\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"transfer\".*"})
	}

	return query
}

// UserSettings retrieves all the user_setting's UserSettings with an executor.
func (o *Account) UserSettings(mods ...qm.QueryMod) userSettingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_setting\".\"account_id\"=?", o.ID),
	)

	query := UserSettings(queryMods...)
	queries.SetFrom(query.Query, "\"user_setting\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"user_setting\".*"})
	}

	return query
}

// Wallets retrieves all the wallet's Wallets with an executor.
func (o *Account) Wallets(mods ...qm.QueryMod) walletQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"wallet\".\"account_id\"=?", o.ID),
	)

	query := Wallets(queryMods...)
	queries.SetFrom(query.Query, "\"wallet\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"wallet\".*"})
	}

	return query
}

// Withdrawals retrieves all the withdrawal's Withdrawals with an executor.
func (o *Account) Withdrawals(mods ...qm.QueryMod) withdrawalQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"withdrawal\".\"account_id\"=?", o.ID),
	)

	query := Withdrawals(queryMods...)
	queries.SetFrom(query.Query, "\"withdrawal\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"withdrawal\".*"})
	}

	return query
}

// LoadAccountTransactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountTransactions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`account_transaction`),
		qm.WhereIn(`account_transaction.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load account_transaction")
	}

	var resultSlice []*AccountTransaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice account_transaction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on account_transaction")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for account_transaction")
	}

	if singular {
		object.R.AccountTransactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountTransactionR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.AccountTransactions = append(local.R.AccountTransactions, foreign)
				if foreign.R == nil {
					foreign.R = &accountTransactionR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadBeneficiaries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadBeneficiaries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`beneficiary`),
		qm.WhereIn(`beneficiary.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load beneficiary")
	}

	var resultSlice []*Beneficiary
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice beneficiary")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on beneficiary")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for beneficiary")
	}

	if singular {
		object.R.Beneficiaries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &beneficiaryR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.AccountID) {
				local.R.Beneficiaries = append(local.R.Beneficiaries, foreign)
				if foreign.R == nil {
					foreign.R = &beneficiaryR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadCryptoAssets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadCryptoAssets(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`crypto_asset`),
		qm.WhereIn(`crypto_asset.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load crypto_asset")
	}

	var resultSlice []*CryptoAsset
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice crypto_asset")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on crypto_asset")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for crypto_asset")
	}

	if singular {
		object.R.CryptoAssets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &cryptoAssetR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.CryptoAssets = append(local.R.CryptoAssets, foreign)
				if foreign.R == nil {
					foreign.R = &cryptoAssetR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadCryptoDeposits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadCryptoDeposits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`crypto_deposit`),
		qm.WhereIn(`crypto_deposit.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load crypto_deposit")
	}

	var resultSlice []*CryptoDeposit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice crypto_deposit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on crypto_deposit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for crypto_deposit")
	}

	if singular {
		object.R.CryptoDeposits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &cryptoDepositR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.CryptoDeposits = append(local.R.CryptoDeposits, foreign)
				if foreign.R == nil {
					foreign.R = &cryptoDepositR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadDailyEarnings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadDailyEarnings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`daily_earning`),
		qm.WhereIn(`daily_earning.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load daily_earning")
	}

	var resultSlice []*DailyEarning
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice daily_earning")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on daily_earning")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for daily_earning")
	}

	if singular {
		object.R.DailyEarnings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dailyEarningR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.DailyEarnings = append(local.R.DailyEarnings, foreign)
				if foreign.R == nil {
					foreign.R = &dailyEarningR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadDeposits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadDeposits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`deposit`),
		qm.WhereIn(`deposit.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load deposit")
	}

	var resultSlice []*Deposit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice deposit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on deposit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for deposit")
	}

	if singular {
		object.R.Deposits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &depositR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Deposits = append(local.R.Deposits, foreign)
				if foreign.R == nil {
					foreign.R = &depositR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadDepositWallets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadDepositWallets(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`deposit_wallet`),
		qm.WhereIn(`deposit_wallet.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load deposit_wallet")
	}

	var resultSlice []*DepositWallet
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice deposit_wallet")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on deposit_wallet")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for deposit_wallet")
	}

	if singular {
		object.R.DepositWallets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &depositWalletR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.DepositWallets = append(local.R.DepositWallets, foreign)
				if foreign.R == nil {
					foreign.R = &depositWalletR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadInvestments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadInvestments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`investment`),
		qm.WhereIn(`investment.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load investment")
	}

	var resultSlice []*Investment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice investment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on investment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for investment")
	}

	if singular {
		object.R.Investments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &investmentR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Investments = append(local.R.Investments, foreign)
				if foreign.R == nil {
					foreign.R = &investmentR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadLoginInfos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadLoginInfos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`login_info`),
		qm.WhereIn(`login_info.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load login_info")
	}

	var resultSlice []*LoginInfo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice login_info")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on login_info")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for login_info")
	}

	if singular {
		object.R.LoginInfos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &loginInfoR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.LoginInfos = append(local.R.LoginInfos, foreign)
				if foreign.R == nil {
					foreign.R = &loginInfoR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadNotifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadNotifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`notification`),
		qm.WhereIn(`notification.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load notification")
	}

	var resultSlice []*Notification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice notification")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on notification")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for notification")
	}

	if singular {
		object.R.Notifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &notificationR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Notifications = append(local.R.Notifications, foreign)
				if foreign.R == nil {
					foreign.R = &notificationR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadPaymentLinks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadPaymentLinks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`payment_link`),
		qm.WhereIn(`payment_link.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load payment_link")
	}

	var resultSlice []*PaymentLink
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice payment_link")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on payment_link")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for payment_link")
	}

	if singular {
		object.R.PaymentLinks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentLinkR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.AccountID) {
				local.R.PaymentLinks = append(local.R.PaymentLinks, foreign)
				if foreign.R == nil {
					foreign.R = &paymentLinkR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadReferralPayouts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadReferralPayouts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`referral_payout`),
		qm.WhereIn(`referral_payout.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load referral_payout")
	}

	var resultSlice []*ReferralPayout
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice referral_payout")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on referral_payout")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for referral_payout")
	}

	if singular {
		object.R.ReferralPayouts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &referralPayoutR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.ReferralPayouts = append(local.R.ReferralPayouts, foreign)
				if foreign.R == nil {
					foreign.R = &referralPayoutR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadFromAccountReferralPayouts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadFromAccountReferralPayouts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`referral_payout`),
		qm.WhereIn(`referral_payout.from_account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load referral_payout")
	}

	var resultSlice []*ReferralPayout
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice referral_payout")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on referral_payout")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for referral_payout")
	}

	if singular {
		object.R.FromAccountReferralPayouts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &referralPayoutR{}
			}
			foreign.R.FromAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FromAccountID {
				local.R.FromAccountReferralPayouts = append(local.R.FromAccountReferralPayouts, foreign)
				if foreign.R == nil {
					foreign.R = &referralPayoutR{}
				}
				foreign.R.FromAccount = local
				break
			}
		}
	}

	return nil
}

// LoadSecurityCodes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadSecurityCodes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`security_code`),
		qm.WhereIn(`security_code.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load security_code")
	}

	var resultSlice []*SecurityCode
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice security_code")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on security_code")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for security_code")
	}

	if singular {
		object.R.SecurityCodes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &securityCodeR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.SecurityCodes = append(local.R.SecurityCodes, foreign)
				if foreign.R == nil {
					foreign.R = &securityCodeR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadStableNairaTransactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadStableNairaTransactions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`stable_naira_transaction`),
		qm.WhereIn(`stable_naira_transaction.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load stable_naira_transaction")
	}

	var resultSlice []*StableNairaTransaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice stable_naira_transaction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on stable_naira_transaction")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for stable_naira_transaction")
	}

	if singular {
		object.R.StableNairaTransactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &stableNairaTransactionR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.StableNairaTransactions = append(local.R.StableNairaTransactions, foreign)
				if foreign.R == nil {
					foreign.R = &stableNairaTransactionR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadSubscriptions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadSubscriptions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`subscription`),
		qm.WhereIn(`subscription.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load subscription")
	}

	var resultSlice []*Subscription
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice subscription")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on subscription")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for subscription")
	}

	if singular {
		object.R.Subscriptions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &subscriptionR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Subscriptions = append(local.R.Subscriptions, foreign)
				if foreign.R == nil {
					foreign.R = &subscriptionR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadTrades allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadTrades(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`trade`),
		qm.WhereIn(`trade.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load trade")
	}

	var resultSlice []*Trade
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice trade")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on trade")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for trade")
	}

	if singular {
		object.R.Trades = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tradeR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Trades = append(local.R.Trades, foreign)
				if foreign.R == nil {
					foreign.R = &tradeR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadTradeSchedules allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadTradeSchedules(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`trade_schedule`),
		qm.WhereIn(`trade_schedule.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load trade_schedule")
	}

	var resultSlice []*TradeSchedule
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice trade_schedule")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on trade_schedule")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for trade_schedule")
	}

	if singular {
		object.R.TradeSchedules = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tradeScheduleR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.TradeSchedules = append(local.R.TradeSchedules, foreign)
				if foreign.R == nil {
					foreign.R = &tradeScheduleR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadReceiverTransfers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadReceiverTransfers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`transfer`),
		qm.WhereIn(`transfer.receiver_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load transfer")
	}

	var resultSlice []*Transfer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice transfer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on transfer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for transfer")
	}

	if singular {
		object.R.ReceiverTransfers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transferR{}
			}
			foreign.R.Receiver = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ReceiverID {
				local.R.ReceiverTransfers = append(local.R.ReceiverTransfers, foreign)
				if foreign.R == nil {
					foreign.R = &transferR{}
				}
				foreign.R.Receiver = local
				break
			}
		}
	}

	return nil
}

// LoadSenderTransfers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadSenderTransfers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`transfer`),
		qm.WhereIn(`transfer.sender_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load transfer")
	}

	var resultSlice []*Transfer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice transfer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on transfer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for transfer")
	}

	if singular {
		object.R.SenderTransfers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transferR{}
			}
			foreign.R.Sender = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.SenderID {
				local.R.SenderTransfers = append(local.R.SenderTransfers, foreign)
				if foreign.R == nil {
					foreign.R = &transferR{}
				}
				foreign.R.Sender = local
				break
			}
		}
	}

	return nil
}

// LoadUserSettings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadUserSettings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_setting`),
		qm.WhereIn(`user_setting.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_setting")
	}

	var resultSlice []*UserSetting
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_setting")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_setting")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_setting")
	}

	if singular {
		object.R.UserSettings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userSettingR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.UserSettings = append(local.R.UserSettings, foreign)
				if foreign.R == nil {
					foreign.R = &userSettingR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadWallets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadWallets(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`wallet`),
		qm.WhereIn(`wallet.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load wallet")
	}

	var resultSlice []*Wallet
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice wallet")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on wallet")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for wallet")
	}

	if singular {
		object.R.Wallets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &walletR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Wallets = append(local.R.Wallets, foreign)
				if foreign.R == nil {
					foreign.R = &walletR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadWithdrawals allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadWithdrawals(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`withdrawal`),
		qm.WhereIn(`withdrawal.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load withdrawal")
	}

	var resultSlice []*Withdrawal
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice withdrawal")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on withdrawal")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for withdrawal")
	}

	if singular {
		object.R.Withdrawals = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &withdrawalR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Withdrawals = append(local.R.Withdrawals, foreign)
				if foreign.R == nil {
					foreign.R = &withdrawalR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// AddAccountTransactions adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.AccountTransactions.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountTransactions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountTransaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"account_transaction\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, accountTransactionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountTransactions: related,
		}
	} else {
		o.R.AccountTransactions = append(o.R.AccountTransactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountTransactionR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddBeneficiaries adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Beneficiaries.
// Sets related.R.Account appropriately.
func (o *Account) AddBeneficiaries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Beneficiary) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AccountID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"beneficiary\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, beneficiaryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AccountID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Beneficiaries: related,
		}
	} else {
		o.R.Beneficiaries = append(o.R.Beneficiaries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &beneficiaryR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// SetBeneficiaries removes all previously related items of the
// account replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Account's Beneficiaries accordingly.
// Replaces o.R.Beneficiaries with related.
// Sets related.R.Account's Beneficiaries accordingly.
func (o *Account) SetBeneficiaries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Beneficiary) error {
	query := "update \"beneficiary\" set \"account_id\" = null where \"account_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Beneficiaries {
			queries.SetScanner(&rel.AccountID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Account = nil
		}

		o.R.Beneficiaries = nil
	}
	return o.AddBeneficiaries(ctx, exec, insert, related...)
}

// RemoveBeneficiaries relationships from objects passed in.
// Removes related items from R.Beneficiaries (uses pointer comparison, removal does not keep order)
// Sets related.R.Account.
func (o *Account) RemoveBeneficiaries(ctx context.Context, exec boil.ContextExecutor, related ...*Beneficiary) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AccountID, nil)
		if rel.R != nil {
			rel.R.Account = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("account_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Beneficiaries {
			if rel != ri {
				continue
			}

			ln := len(o.R.Beneficiaries)
			if ln > 1 && i < ln-1 {
				o.R.Beneficiaries[i] = o.R.Beneficiaries[ln-1]
			}
			o.R.Beneficiaries = o.R.Beneficiaries[:ln-1]
			break
		}
	}

	return nil
}

// AddCryptoAssets adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.CryptoAssets.
// Sets related.R.Account appropriately.
func (o *Account) AddCryptoAssets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CryptoAsset) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"crypto_asset\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, cryptoAssetPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			CryptoAssets: related,
		}
	} else {
		o.R.CryptoAssets = append(o.R.CryptoAssets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &cryptoAssetR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddCryptoDeposits adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.CryptoDeposits.
// Sets related.R.Account appropriately.
func (o *Account) AddCryptoDeposits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CryptoDeposit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"crypto_deposit\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, cryptoDepositPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.TransactionHash}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			CryptoDeposits: related,
		}
	} else {
		o.R.CryptoDeposits = append(o.R.CryptoDeposits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &cryptoDepositR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddDailyEarnings adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.DailyEarnings.
// Sets related.R.Account appropriately.
func (o *Account) AddDailyEarnings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DailyEarning) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"daily_earning\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, dailyEarningPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			DailyEarnings: related,
		}
	} else {
		o.R.DailyEarnings = append(o.R.DailyEarnings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dailyEarningR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddDeposits adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Deposits.
// Sets related.R.Account appropriately.
func (o *Account) AddDeposits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Deposit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"deposit\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, depositPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Deposits: related,
		}
	} else {
		o.R.Deposits = append(o.R.Deposits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &depositR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddDepositWallets adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.DepositWallets.
// Sets related.R.Account appropriately.
func (o *Account) AddDepositWallets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DepositWallet) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"deposit_wallet\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, depositWalletPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.Address}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			DepositWallets: related,
		}
	} else {
		o.R.DepositWallets = append(o.R.DepositWallets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &depositWalletR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddInvestments adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Investments.
// Sets related.R.Account appropriately.
func (o *Account) AddInvestments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Investment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"investment\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, investmentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Investments: related,
		}
	} else {
		o.R.Investments = append(o.R.Investments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &investmentR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddLoginInfos adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.LoginInfos.
// Sets related.R.Account appropriately.
func (o *Account) AddLoginInfos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LoginInfo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"login_info\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, loginInfoPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			LoginInfos: related,
		}
	} else {
		o.R.LoginInfos = append(o.R.LoginInfos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &loginInfoR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddNotifications adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Notifications.
// Sets related.R.Account appropriately.
func (o *Account) AddNotifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Notification) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"notification\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, notificationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Notifications: related,
		}
	} else {
		o.R.Notifications = append(o.R.Notifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &notificationR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddPaymentLinks adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.PaymentLinks.
// Sets related.R.Account appropriately.
func (o *Account) AddPaymentLinks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentLink) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AccountID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"payment_link\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, paymentLinkPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.Permalink}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AccountID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &accountR{
			PaymentLinks: related,
		}
	} else {
		o.R.PaymentLinks = append(o.R.PaymentLinks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentLinkR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// SetPaymentLinks removes all previously related items of the
// account replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Account's PaymentLinks accordingly.
// Replaces o.R.PaymentLinks with related.
// Sets related.R.Account's PaymentLinks accordingly.
func (o *Account) SetPaymentLinks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PaymentLink) error {
	query := "update \"payment_link\" set \"account_id\" = null where \"account_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PaymentLinks {
			queries.SetScanner(&rel.AccountID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Account = nil
		}

		o.R.PaymentLinks = nil
	}
	return o.AddPaymentLinks(ctx, exec, insert, related...)
}

// RemovePaymentLinks relationships from objects passed in.
// Removes related items from R.PaymentLinks (uses pointer comparison, removal does not keep order)
// Sets related.R.Account.
func (o *Account) RemovePaymentLinks(ctx context.Context, exec boil.ContextExecutor, related ...*PaymentLink) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AccountID, nil)
		if rel.R != nil {
			rel.R.Account = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("account_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PaymentLinks {
			if rel != ri {
				continue
			}

			ln := len(o.R.PaymentLinks)
			if ln > 1 && i < ln-1 {
				o.R.PaymentLinks[i] = o.R.PaymentLinks[ln-1]
			}
			o.R.PaymentLinks = o.R.PaymentLinks[:ln-1]
			break
		}
	}

	return nil
}

// AddReferralPayouts adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.ReferralPayouts.
// Sets related.R.Account appropriately.
func (o *Account) AddReferralPayouts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ReferralPayout) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"referral_payout\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, referralPayoutPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			ReferralPayouts: related,
		}
	} else {
		o.R.ReferralPayouts = append(o.R.ReferralPayouts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &referralPayoutR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddFromAccountReferralPayouts adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.FromAccountReferralPayouts.
// Sets related.R.FromAccount appropriately.
func (o *Account) AddFromAccountReferralPayouts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ReferralPayout) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"referral_payout\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"from_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, referralPayoutPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			FromAccountReferralPayouts: related,
		}
	} else {
		o.R.FromAccountReferralPayouts = append(o.R.FromAccountReferralPayouts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &referralPayoutR{
				FromAccount: o,
			}
		} else {
			rel.R.FromAccount = o
		}
	}
	return nil
}

// AddSecurityCodes adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.SecurityCodes.
// Sets related.R.Account appropriately.
func (o *Account) AddSecurityCodes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SecurityCode) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"security_code\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, securityCodePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			SecurityCodes: related,
		}
	} else {
		o.R.SecurityCodes = append(o.R.SecurityCodes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &securityCodeR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddStableNairaTransactions adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.StableNairaTransactions.
// Sets related.R.Account appropriately.
func (o *Account) AddStableNairaTransactions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*StableNairaTransaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"stable_naira_transaction\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, stableNairaTransactionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			StableNairaTransactions: related,
		}
	} else {
		o.R.StableNairaTransactions = append(o.R.StableNairaTransactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &stableNairaTransactionR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddSubscriptions adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Subscriptions.
// Sets related.R.Account appropriately.
func (o *Account) AddSubscriptions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Subscription) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"subscription\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, subscriptionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Subscriptions: related,
		}
	} else {
		o.R.Subscriptions = append(o.R.Subscriptions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &subscriptionR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddTrades adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Trades.
// Sets related.R.Account appropriately.
func (o *Account) AddTrades(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Trade) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"trade\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, tradePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Trades: related,
		}
	} else {
		o.R.Trades = append(o.R.Trades, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tradeR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddTradeSchedules adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.TradeSchedules.
// Sets related.R.Account appropriately.
func (o *Account) AddTradeSchedules(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TradeSchedule) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"trade_schedule\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, tradeSchedulePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			TradeSchedules: related,
		}
	} else {
		o.R.TradeSchedules = append(o.R.TradeSchedules, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tradeScheduleR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddReceiverTransfers adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.ReceiverTransfers.
// Sets related.R.Receiver appropriately.
func (o *Account) AddReceiverTransfers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Transfer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReceiverID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"transfer\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"receiver_id"}),
				strmangle.WhereClause("\"", "\"", 2, transferPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReceiverID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			ReceiverTransfers: related,
		}
	} else {
		o.R.ReceiverTransfers = append(o.R.ReceiverTransfers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transferR{
				Receiver: o,
			}
		} else {
			rel.R.Receiver = o
		}
	}
	return nil
}

// AddSenderTransfers adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.SenderTransfers.
// Sets related.R.Sender appropriately.
func (o *Account) AddSenderTransfers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Transfer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.SenderID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"transfer\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"sender_id"}),
				strmangle.WhereClause("\"", "\"", 2, transferPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.SenderID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			SenderTransfers: related,
		}
	} else {
		o.R.SenderTransfers = append(o.R.SenderTransfers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transferR{
				Sender: o,
			}
		} else {
			rel.R.Sender = o
		}
	}
	return nil
}

// AddUserSettings adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.UserSettings.
// Sets related.R.Account appropriately.
func (o *Account) AddUserSettings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserSetting) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_setting\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, userSettingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			UserSettings: related,
		}
	} else {
		o.R.UserSettings = append(o.R.UserSettings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userSettingR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddWallets adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Wallets.
// Sets related.R.Account appropriately.
func (o *Account) AddWallets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Wallet) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"wallet\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, walletPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Wallets: related,
		}
	} else {
		o.R.Wallets = append(o.R.Wallets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &walletR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddWithdrawals adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Withdrawals.
// Sets related.R.Account appropriately.
func (o *Account) AddWithdrawals(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Withdrawal) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"withdrawal\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, withdrawalPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Withdrawals: related,
		}
	} else {
		o.R.Withdrawals = append(o.R.Withdrawals, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &withdrawalR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// Accounts retrieves all the records using an executor.
func Accounts(mods ...qm.QueryMod) accountQuery {
	mods = append(mods, qm.From("\"account\""))
	return accountQuery{NewQuery(mods...)}
}

// FindAccount retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAccount(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Account, error) {
	accountObj := &Account{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"account\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, accountObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from account")
	}

	return accountObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Account) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no account provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(accountColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	accountInsertCacheMut.RLock()
	cache, cached := accountInsertCache[key]
	accountInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			accountAllColumns,
			accountColumnsWithDefault,
			accountColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(accountType, accountMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"account\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"account\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into account")
	}

	if !cached {
		accountInsertCacheMut.Lock()
		accountInsertCache[key] = cache
		accountInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Account.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Account) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	accountUpdateCacheMut.RLock()
	cache, cached := accountUpdateCache[key]
	accountUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			accountAllColumns,
			accountPrimaryKeyColumns,
		)

		if len(wl) == 0 {
			return 0, errors.New("models: unable to update account, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"account\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, accountPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, append(wl, accountPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update account row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for account")
	}

	if !cached {
		accountUpdateCacheMut.Lock()
		accountUpdateCache[key] = cache
		accountUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q accountQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for account")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AccountSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"account\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, accountPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in account slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all account")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Account) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no account provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(accountColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	accountUpsertCacheMut.RLock()
	cache, cached := accountUpsertCache[key]
	accountUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			accountAllColumns,
			accountColumnsWithDefault,
			accountColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			accountAllColumns,
			accountPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert account, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(accountPrimaryKeyColumns))
			copy(conflict, accountPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"account\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(accountType, accountMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert account")
	}

	if !cached {
		accountUpsertCacheMut.Lock()
		accountUpsertCache[key] = cache
		accountUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Account record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Account) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Account provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), accountPrimaryKeyMapping)
	sql := "DELETE FROM \"account\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for account")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q accountQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no accountQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for account")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AccountSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"account\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, accountPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from account slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for account")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Account) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAccount(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AccountSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AccountSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"account\".* FROM \"account\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, accountPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in AccountSlice")
	}

	*o = slice

	return nil
}

// AccountExists checks if the Account row exists.
func AccountExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"account\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if account exists")
	}

	return exists, nil
}
