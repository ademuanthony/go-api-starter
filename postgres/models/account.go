// Code generated by SQLBoiler 4.7.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Account is an object representing the database table.
type Account struct {
	ID                 string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	TelegramID         int64       `boil:"telegram_id" json:"telegram_id" toml:"telegram_id" yaml:"telegram_id"`
	ReferralCode       string      `boil:"referral_code" json:"referral_code" toml:"referral_code" yaml:"referral_code"`
	Username           string      `boil:"username" json:"username" toml:"username" yaml:"username"`
	Password           string      `boil:"password" json:"password" toml:"password" yaml:"password"`
	Email              string      `boil:"email" json:"email" toml:"email" yaml:"email"`
	PhoneNumber        string      `boil:"phone_number" json:"phone_number" toml:"phone_number" yaml:"phone_number"`
	CreatedAt          int64       `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	FirstName          string      `boil:"first_name" json:"first_name" toml:"first_name" yaml:"first_name"`
	LastName           string      `boil:"last_name" json:"last_name" toml:"last_name" yaml:"last_name"`
	ReferralID         null.String `boil:"referral_id" json:"referral_id,omitempty" toml:"referral_id" yaml:"referral_id,omitempty"`
	ReferralID2        null.String `boil:"referral_id_2" json:"referral_id_2,omitempty" toml:"referral_id_2" yaml:"referral_id_2,omitempty"`
	ReferralID3        null.String `boil:"referral_id_3" json:"referral_id_3,omitempty" toml:"referral_id_3" yaml:"referral_id_3,omitempty"`
	WithdrawalAddresss string      `boil:"withdrawal_addresss" json:"withdrawal_addresss" toml:"withdrawal_addresss" yaml:"withdrawal_addresss"`
	Balance            int64       `boil:"balance" json:"balance" toml:"balance" yaml:"balance"`
	Principal          int64       `boil:"principal" json:"principal" toml:"principal" yaml:"principal"`
	MaturedPrincipal   int64       `boil:"matured_principal" json:"matured_principal" toml:"matured_principal" yaml:"matured_principal"`
	ReferralEarning    int64       `boil:"referral_earning" json:"referral_earning" toml:"referral_earning" yaml:"referral_earning"`
	StableNaira        int64       `boil:"stable_naira" json:"stable_naira" toml:"stable_naira" yaml:"stable_naira"`

	R *accountR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L accountL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AccountColumns = struct {
	ID                 string
	TelegramID         string
	ReferralCode       string
	Username           string
	Password           string
	Email              string
	PhoneNumber        string
	CreatedAt          string
	FirstName          string
	LastName           string
	ReferralID         string
	ReferralID2        string
	ReferralID3        string
	WithdrawalAddresss string
	Balance            string
	Principal          string
	MaturedPrincipal   string
	ReferralEarning    string
	StableNaira        string
}{
	ID:                 "id",
	TelegramID:         "telegram_id",
	ReferralCode:       "referral_code",
	Username:           "username",
	Password:           "password",
	Email:              "email",
	PhoneNumber:        "phone_number",
	CreatedAt:          "created_at",
	FirstName:          "first_name",
	LastName:           "last_name",
	ReferralID:         "referral_id",
	ReferralID2:        "referral_id_2",
	ReferralID3:        "referral_id_3",
	WithdrawalAddresss: "withdrawal_addresss",
	Balance:            "balance",
	Principal:          "principal",
	MaturedPrincipal:   "matured_principal",
	ReferralEarning:    "referral_earning",
	StableNaira:        "stable_naira",
}

var AccountTableColumns = struct {
	ID                 string
	TelegramID         string
	ReferralCode       string
	Username           string
	Password           string
	Email              string
	PhoneNumber        string
	CreatedAt          string
	FirstName          string
	LastName           string
	ReferralID         string
	ReferralID2        string
	ReferralID3        string
	WithdrawalAddresss string
	Balance            string
	Principal          string
	MaturedPrincipal   string
	ReferralEarning    string
	StableNaira        string
}{
	ID:                 "account.id",
	TelegramID:         "account.telegram_id",
	ReferralCode:       "account.referral_code",
	Username:           "account.username",
	Password:           "account.password",
	Email:              "account.email",
	PhoneNumber:        "account.phone_number",
	CreatedAt:          "account.created_at",
	FirstName:          "account.first_name",
	LastName:           "account.last_name",
	ReferralID:         "account.referral_id",
	ReferralID2:        "account.referral_id_2",
	ReferralID3:        "account.referral_id_3",
	WithdrawalAddresss: "account.withdrawal_addresss",
	Balance:            "account.balance",
	Principal:          "account.principal",
	MaturedPrincipal:   "account.matured_principal",
	ReferralEarning:    "account.referral_earning",
	StableNaira:        "account.stable_naira",
}

// Generated where

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperstring) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var AccountWhere = struct {
	ID                 whereHelperstring
	TelegramID         whereHelperint64
	ReferralCode       whereHelperstring
	Username           whereHelperstring
	Password           whereHelperstring
	Email              whereHelperstring
	PhoneNumber        whereHelperstring
	CreatedAt          whereHelperint64
	FirstName          whereHelperstring
	LastName           whereHelperstring
	ReferralID         whereHelpernull_String
	ReferralID2        whereHelpernull_String
	ReferralID3        whereHelpernull_String
	WithdrawalAddresss whereHelperstring
	Balance            whereHelperint64
	Principal          whereHelperint64
	MaturedPrincipal   whereHelperint64
	ReferralEarning    whereHelperint64
	StableNaira        whereHelperint64
}{
	ID:                 whereHelperstring{field: "\"account\".\"id\""},
	TelegramID:         whereHelperint64{field: "\"account\".\"telegram_id\""},
	ReferralCode:       whereHelperstring{field: "\"account\".\"referral_code\""},
	Username:           whereHelperstring{field: "\"account\".\"username\""},
	Password:           whereHelperstring{field: "\"account\".\"password\""},
	Email:              whereHelperstring{field: "\"account\".\"email\""},
	PhoneNumber:        whereHelperstring{field: "\"account\".\"phone_number\""},
	CreatedAt:          whereHelperint64{field: "\"account\".\"created_at\""},
	FirstName:          whereHelperstring{field: "\"account\".\"first_name\""},
	LastName:           whereHelperstring{field: "\"account\".\"last_name\""},
	ReferralID:         whereHelpernull_String{field: "\"account\".\"referral_id\""},
	ReferralID2:        whereHelpernull_String{field: "\"account\".\"referral_id_2\""},
	ReferralID3:        whereHelpernull_String{field: "\"account\".\"referral_id_3\""},
	WithdrawalAddresss: whereHelperstring{field: "\"account\".\"withdrawal_addresss\""},
	Balance:            whereHelperint64{field: "\"account\".\"balance\""},
	Principal:          whereHelperint64{field: "\"account\".\"principal\""},
	MaturedPrincipal:   whereHelperint64{field: "\"account\".\"matured_principal\""},
	ReferralEarning:    whereHelperint64{field: "\"account\".\"referral_earning\""},
	StableNaira:        whereHelperint64{field: "\"account\".\"stable_naira\""},
}

// AccountRels is where relationship names are stored.
var AccountRels = struct {
	AccountTransactions        string
	DailyEarnings              string
	Deposits                   string
	Investments                string
	LoginInfos                 string
	Notifications              string
	ReferralPayouts            string
	FromAccountReferralPayouts string
	SecurityCodes              string
	UserSettings               string
	Wallets                    string
	Withdrawals                string
}{
	AccountTransactions:        "AccountTransactions",
	DailyEarnings:              "DailyEarnings",
	Deposits:                   "Deposits",
	Investments:                "Investments",
	LoginInfos:                 "LoginInfos",
	Notifications:              "Notifications",
	ReferralPayouts:            "ReferralPayouts",
	FromAccountReferralPayouts: "FromAccountReferralPayouts",
	SecurityCodes:              "SecurityCodes",
	UserSettings:               "UserSettings",
	Wallets:                    "Wallets",
	Withdrawals:                "Withdrawals",
}

// accountR is where relationships are stored.
type accountR struct {
	AccountTransactions        AccountTransactionSlice `boil:"AccountTransactions" json:"AccountTransactions" toml:"AccountTransactions" yaml:"AccountTransactions"`
	DailyEarnings              DailyEarningSlice       `boil:"DailyEarnings" json:"DailyEarnings" toml:"DailyEarnings" yaml:"DailyEarnings"`
	Deposits                   DepositSlice            `boil:"Deposits" json:"Deposits" toml:"Deposits" yaml:"Deposits"`
	Investments                InvestmentSlice         `boil:"Investments" json:"Investments" toml:"Investments" yaml:"Investments"`
	LoginInfos                 LoginInfoSlice          `boil:"LoginInfos" json:"LoginInfos" toml:"LoginInfos" yaml:"LoginInfos"`
	Notifications              NotificationSlice       `boil:"Notifications" json:"Notifications" toml:"Notifications" yaml:"Notifications"`
	ReferralPayouts            ReferralPayoutSlice     `boil:"ReferralPayouts" json:"ReferralPayouts" toml:"ReferralPayouts" yaml:"ReferralPayouts"`
	FromAccountReferralPayouts ReferralPayoutSlice     `boil:"FromAccountReferralPayouts" json:"FromAccountReferralPayouts" toml:"FromAccountReferralPayouts" yaml:"FromAccountReferralPayouts"`
	SecurityCodes              SecurityCodeSlice       `boil:"SecurityCodes" json:"SecurityCodes" toml:"SecurityCodes" yaml:"SecurityCodes"`
	UserSettings               UserSettingSlice        `boil:"UserSettings" json:"UserSettings" toml:"UserSettings" yaml:"UserSettings"`
	Wallets                    WalletSlice             `boil:"Wallets" json:"Wallets" toml:"Wallets" yaml:"Wallets"`
	Withdrawals                WithdrawalSlice         `boil:"Withdrawals" json:"Withdrawals" toml:"Withdrawals" yaml:"Withdrawals"`
}

// NewStruct creates a new relationship struct
func (*accountR) NewStruct() *accountR {
	return &accountR{}
}

// accountL is where Load methods for each relationship are stored.
type accountL struct{}

var (
	accountAllColumns            = []string{"id", "telegram_id", "referral_code", "username", "password", "email", "phone_number", "created_at", "first_name", "last_name", "referral_id", "referral_id_2", "referral_id_3", "withdrawal_addresss", "balance", "principal", "matured_principal", "referral_earning", "stable_naira"}
	accountColumnsWithoutDefault = []string{"id", "telegram_id", "referral_code", "username", "password", "email", "phone_number", "created_at"}
	accountColumnsWithDefault    = []string{"first_name", "last_name", "referral_id", "referral_id_2", "referral_id_3", "withdrawal_addresss", "balance", "principal", "matured_principal", "referral_earning", "stable_naira"}
	accountPrimaryKeyColumns     = []string{"id"}
)

type (
	// AccountSlice is an alias for a slice of pointers to Account.
	// This should almost always be used instead of []Account.
	AccountSlice []*Account

	accountQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	accountType                 = reflect.TypeOf(&Account{})
	accountMapping              = queries.MakeStructMapping(accountType)
	accountPrimaryKeyMapping, _ = queries.BindMapping(accountType, accountMapping, accountPrimaryKeyColumns)
	accountInsertCacheMut       sync.RWMutex
	accountInsertCache          = make(map[string]insertCache)
	accountUpdateCacheMut       sync.RWMutex
	accountUpdateCache          = make(map[string]updateCache)
	accountUpsertCacheMut       sync.RWMutex
	accountUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single account record from the query.
func (q accountQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Account, error) {
	o := &Account{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for account")
	}

	return o, nil
}

// All returns all Account records from the query.
func (q accountQuery) All(ctx context.Context, exec boil.ContextExecutor) (AccountSlice, error) {
	var o []*Account

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Account slice")
	}

	return o, nil
}

// Count returns the count of all Account records in the query.
func (q accountQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count account rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q accountQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if account exists")
	}

	return count > 0, nil
}

// AccountTransactions retrieves all the account_transaction's AccountTransactions with an executor.
func (o *Account) AccountTransactions(mods ...qm.QueryMod) accountTransactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"account_transaction\".\"account_id\"=?", o.ID),
	)

	query := AccountTransactions(queryMods...)
	queries.SetFrom(query.Query, "\"account_transaction\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"account_transaction\".*"})
	}

	return query
}

// DailyEarnings retrieves all the daily_earning's DailyEarnings with an executor.
func (o *Account) DailyEarnings(mods ...qm.QueryMod) dailyEarningQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"daily_earning\".\"account_id\"=?", o.ID),
	)

	query := DailyEarnings(queryMods...)
	queries.SetFrom(query.Query, "\"daily_earning\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"daily_earning\".*"})
	}

	return query
}

// Deposits retrieves all the deposit's Deposits with an executor.
func (o *Account) Deposits(mods ...qm.QueryMod) depositQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"deposit\".\"account_id\"=?", o.ID),
	)

	query := Deposits(queryMods...)
	queries.SetFrom(query.Query, "\"deposit\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"deposit\".*"})
	}

	return query
}

// Investments retrieves all the investment's Investments with an executor.
func (o *Account) Investments(mods ...qm.QueryMod) investmentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"investment\".\"account_id\"=?", o.ID),
	)

	query := Investments(queryMods...)
	queries.SetFrom(query.Query, "\"investment\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"investment\".*"})
	}

	return query
}

// LoginInfos retrieves all the login_info's LoginInfos with an executor.
func (o *Account) LoginInfos(mods ...qm.QueryMod) loginInfoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"login_info\".\"account_id\"=?", o.ID),
	)

	query := LoginInfos(queryMods...)
	queries.SetFrom(query.Query, "\"login_info\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"login_info\".*"})
	}

	return query
}

// Notifications retrieves all the notification's Notifications with an executor.
func (o *Account) Notifications(mods ...qm.QueryMod) notificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"notification\".\"account_id\"=?", o.ID),
	)

	query := Notifications(queryMods...)
	queries.SetFrom(query.Query, "\"notification\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"notification\".*"})
	}

	return query
}

// ReferralPayouts retrieves all the referral_payout's ReferralPayouts with an executor.
func (o *Account) ReferralPayouts(mods ...qm.QueryMod) referralPayoutQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"referral_payout\".\"account_id\"=?", o.ID),
	)

	query := ReferralPayouts(queryMods...)
	queries.SetFrom(query.Query, "\"referral_payout\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"referral_payout\".*"})
	}

	return query
}

// FromAccountReferralPayouts retrieves all the referral_payout's ReferralPayouts with an executor via from_account_id column.
func (o *Account) FromAccountReferralPayouts(mods ...qm.QueryMod) referralPayoutQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"referral_payout\".\"from_account_id\"=?", o.ID),
	)

	query := ReferralPayouts(queryMods...)
	queries.SetFrom(query.Query, "\"referral_payout\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"referral_payout\".*"})
	}

	return query
}

// SecurityCodes retrieves all the security_code's SecurityCodes with an executor.
func (o *Account) SecurityCodes(mods ...qm.QueryMod) securityCodeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"security_code\".\"account_id\"=?", o.ID),
	)

	query := SecurityCodes(queryMods...)
	queries.SetFrom(query.Query, "\"security_code\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"security_code\".*"})
	}

	return query
}

// UserSettings retrieves all the user_setting's UserSettings with an executor.
func (o *Account) UserSettings(mods ...qm.QueryMod) userSettingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_setting\".\"account_id\"=?", o.ID),
	)

	query := UserSettings(queryMods...)
	queries.SetFrom(query.Query, "\"user_setting\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"user_setting\".*"})
	}

	return query
}

// Wallets retrieves all the wallet's Wallets with an executor.
func (o *Account) Wallets(mods ...qm.QueryMod) walletQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"wallet\".\"account_id\"=?", o.ID),
	)

	query := Wallets(queryMods...)
	queries.SetFrom(query.Query, "\"wallet\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"wallet\".*"})
	}

	return query
}

// Withdrawals retrieves all the withdrawal's Withdrawals with an executor.
func (o *Account) Withdrawals(mods ...qm.QueryMod) withdrawalQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"withdrawal\".\"account_id\"=?", o.ID),
	)

	query := Withdrawals(queryMods...)
	queries.SetFrom(query.Query, "\"withdrawal\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"withdrawal\".*"})
	}

	return query
}

// LoadAccountTransactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountTransactions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`account_transaction`),
		qm.WhereIn(`account_transaction.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load account_transaction")
	}

	var resultSlice []*AccountTransaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice account_transaction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on account_transaction")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for account_transaction")
	}

	if singular {
		object.R.AccountTransactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountTransactionR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.AccountTransactions = append(local.R.AccountTransactions, foreign)
				if foreign.R == nil {
					foreign.R = &accountTransactionR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadDailyEarnings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadDailyEarnings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`daily_earning`),
		qm.WhereIn(`daily_earning.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load daily_earning")
	}

	var resultSlice []*DailyEarning
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice daily_earning")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on daily_earning")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for daily_earning")
	}

	if singular {
		object.R.DailyEarnings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dailyEarningR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.DailyEarnings = append(local.R.DailyEarnings, foreign)
				if foreign.R == nil {
					foreign.R = &dailyEarningR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadDeposits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadDeposits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`deposit`),
		qm.WhereIn(`deposit.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load deposit")
	}

	var resultSlice []*Deposit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice deposit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on deposit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for deposit")
	}

	if singular {
		object.R.Deposits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &depositR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Deposits = append(local.R.Deposits, foreign)
				if foreign.R == nil {
					foreign.R = &depositR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadInvestments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadInvestments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`investment`),
		qm.WhereIn(`investment.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load investment")
	}

	var resultSlice []*Investment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice investment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on investment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for investment")
	}

	if singular {
		object.R.Investments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &investmentR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Investments = append(local.R.Investments, foreign)
				if foreign.R == nil {
					foreign.R = &investmentR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadLoginInfos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadLoginInfos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`login_info`),
		qm.WhereIn(`login_info.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load login_info")
	}

	var resultSlice []*LoginInfo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice login_info")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on login_info")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for login_info")
	}

	if singular {
		object.R.LoginInfos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &loginInfoR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.LoginInfos = append(local.R.LoginInfos, foreign)
				if foreign.R == nil {
					foreign.R = &loginInfoR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadNotifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadNotifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`notification`),
		qm.WhereIn(`notification.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load notification")
	}

	var resultSlice []*Notification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice notification")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on notification")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for notification")
	}

	if singular {
		object.R.Notifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &notificationR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Notifications = append(local.R.Notifications, foreign)
				if foreign.R == nil {
					foreign.R = &notificationR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadReferralPayouts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadReferralPayouts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`referral_payout`),
		qm.WhereIn(`referral_payout.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load referral_payout")
	}

	var resultSlice []*ReferralPayout
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice referral_payout")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on referral_payout")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for referral_payout")
	}

	if singular {
		object.R.ReferralPayouts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &referralPayoutR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.ReferralPayouts = append(local.R.ReferralPayouts, foreign)
				if foreign.R == nil {
					foreign.R = &referralPayoutR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadFromAccountReferralPayouts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadFromAccountReferralPayouts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`referral_payout`),
		qm.WhereIn(`referral_payout.from_account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load referral_payout")
	}

	var resultSlice []*ReferralPayout
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice referral_payout")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on referral_payout")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for referral_payout")
	}

	if singular {
		object.R.FromAccountReferralPayouts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &referralPayoutR{}
			}
			foreign.R.FromAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FromAccountID {
				local.R.FromAccountReferralPayouts = append(local.R.FromAccountReferralPayouts, foreign)
				if foreign.R == nil {
					foreign.R = &referralPayoutR{}
				}
				foreign.R.FromAccount = local
				break
			}
		}
	}

	return nil
}

// LoadSecurityCodes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadSecurityCodes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`security_code`),
		qm.WhereIn(`security_code.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load security_code")
	}

	var resultSlice []*SecurityCode
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice security_code")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on security_code")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for security_code")
	}

	if singular {
		object.R.SecurityCodes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &securityCodeR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.SecurityCodes = append(local.R.SecurityCodes, foreign)
				if foreign.R == nil {
					foreign.R = &securityCodeR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadUserSettings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadUserSettings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_setting`),
		qm.WhereIn(`user_setting.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_setting")
	}

	var resultSlice []*UserSetting
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_setting")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_setting")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_setting")
	}

	if singular {
		object.R.UserSettings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userSettingR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.UserSettings = append(local.R.UserSettings, foreign)
				if foreign.R == nil {
					foreign.R = &userSettingR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadWallets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadWallets(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`wallet`),
		qm.WhereIn(`wallet.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load wallet")
	}

	var resultSlice []*Wallet
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice wallet")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on wallet")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for wallet")
	}

	if singular {
		object.R.Wallets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &walletR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Wallets = append(local.R.Wallets, foreign)
				if foreign.R == nil {
					foreign.R = &walletR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadWithdrawals allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadWithdrawals(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`withdrawal`),
		qm.WhereIn(`withdrawal.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load withdrawal")
	}

	var resultSlice []*Withdrawal
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice withdrawal")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on withdrawal")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for withdrawal")
	}

	if singular {
		object.R.Withdrawals = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &withdrawalR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Withdrawals = append(local.R.Withdrawals, foreign)
				if foreign.R == nil {
					foreign.R = &withdrawalR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// AddAccountTransactions adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.AccountTransactions.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountTransactions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountTransaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"account_transaction\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, accountTransactionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountTransactions: related,
		}
	} else {
		o.R.AccountTransactions = append(o.R.AccountTransactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountTransactionR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddDailyEarnings adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.DailyEarnings.
// Sets related.R.Account appropriately.
func (o *Account) AddDailyEarnings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DailyEarning) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"daily_earning\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, dailyEarningPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			DailyEarnings: related,
		}
	} else {
		o.R.DailyEarnings = append(o.R.DailyEarnings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dailyEarningR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddDeposits adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Deposits.
// Sets related.R.Account appropriately.
func (o *Account) AddDeposits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Deposit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"deposit\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, depositPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Deposits: related,
		}
	} else {
		o.R.Deposits = append(o.R.Deposits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &depositR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddInvestments adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Investments.
// Sets related.R.Account appropriately.
func (o *Account) AddInvestments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Investment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"investment\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, investmentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Investments: related,
		}
	} else {
		o.R.Investments = append(o.R.Investments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &investmentR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddLoginInfos adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.LoginInfos.
// Sets related.R.Account appropriately.
func (o *Account) AddLoginInfos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LoginInfo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"login_info\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, loginInfoPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			LoginInfos: related,
		}
	} else {
		o.R.LoginInfos = append(o.R.LoginInfos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &loginInfoR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddNotifications adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Notifications.
// Sets related.R.Account appropriately.
func (o *Account) AddNotifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Notification) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"notification\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, notificationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Notifications: related,
		}
	} else {
		o.R.Notifications = append(o.R.Notifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &notificationR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddReferralPayouts adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.ReferralPayouts.
// Sets related.R.Account appropriately.
func (o *Account) AddReferralPayouts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ReferralPayout) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"referral_payout\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, referralPayoutPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			ReferralPayouts: related,
		}
	} else {
		o.R.ReferralPayouts = append(o.R.ReferralPayouts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &referralPayoutR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddFromAccountReferralPayouts adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.FromAccountReferralPayouts.
// Sets related.R.FromAccount appropriately.
func (o *Account) AddFromAccountReferralPayouts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ReferralPayout) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"referral_payout\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"from_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, referralPayoutPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			FromAccountReferralPayouts: related,
		}
	} else {
		o.R.FromAccountReferralPayouts = append(o.R.FromAccountReferralPayouts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &referralPayoutR{
				FromAccount: o,
			}
		} else {
			rel.R.FromAccount = o
		}
	}
	return nil
}

// AddSecurityCodes adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.SecurityCodes.
// Sets related.R.Account appropriately.
func (o *Account) AddSecurityCodes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SecurityCode) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"security_code\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, securityCodePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			SecurityCodes: related,
		}
	} else {
		o.R.SecurityCodes = append(o.R.SecurityCodes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &securityCodeR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddUserSettings adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.UserSettings.
// Sets related.R.Account appropriately.
func (o *Account) AddUserSettings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserSetting) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_setting\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, userSettingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			UserSettings: related,
		}
	} else {
		o.R.UserSettings = append(o.R.UserSettings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userSettingR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddWallets adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Wallets.
// Sets related.R.Account appropriately.
func (o *Account) AddWallets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Wallet) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"wallet\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, walletPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Wallets: related,
		}
	} else {
		o.R.Wallets = append(o.R.Wallets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &walletR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddWithdrawals adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Withdrawals.
// Sets related.R.Account appropriately.
func (o *Account) AddWithdrawals(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Withdrawal) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"withdrawal\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, withdrawalPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Withdrawals: related,
		}
	} else {
		o.R.Withdrawals = append(o.R.Withdrawals, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &withdrawalR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// Accounts retrieves all the records using an executor.
func Accounts(mods ...qm.QueryMod) accountQuery {
	mods = append(mods, qm.From("\"account\""))
	return accountQuery{NewQuery(mods...)}
}

// FindAccount retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAccount(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Account, error) {
	accountObj := &Account{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"account\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, accountObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from account")
	}

	return accountObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Account) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no account provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(accountColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	accountInsertCacheMut.RLock()
	cache, cached := accountInsertCache[key]
	accountInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			accountAllColumns,
			accountColumnsWithDefault,
			accountColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(accountType, accountMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"account\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"account\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into account")
	}

	if !cached {
		accountInsertCacheMut.Lock()
		accountInsertCache[key] = cache
		accountInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Account.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Account) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	accountUpdateCacheMut.RLock()
	cache, cached := accountUpdateCache[key]
	accountUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			accountAllColumns,
			accountPrimaryKeyColumns,
		)

		if len(wl) == 0 {
			return 0, errors.New("models: unable to update account, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"account\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, accountPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, append(wl, accountPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update account row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for account")
	}

	if !cached {
		accountUpdateCacheMut.Lock()
		accountUpdateCache[key] = cache
		accountUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q accountQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for account")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AccountSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"account\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, accountPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in account slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all account")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Account) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no account provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(accountColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	accountUpsertCacheMut.RLock()
	cache, cached := accountUpsertCache[key]
	accountUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			accountAllColumns,
			accountColumnsWithDefault,
			accountColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			accountAllColumns,
			accountPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert account, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(accountPrimaryKeyColumns))
			copy(conflict, accountPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"account\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(accountType, accountMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert account")
	}

	if !cached {
		accountUpsertCacheMut.Lock()
		accountUpsertCache[key] = cache
		accountUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Account record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Account) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Account provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), accountPrimaryKeyMapping)
	sql := "DELETE FROM \"account\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for account")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q accountQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no accountQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for account")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AccountSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"account\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, accountPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from account slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for account")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Account) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAccount(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AccountSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AccountSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"account\".* FROM \"account\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, accountPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in AccountSlice")
	}

	*o = slice

	return nil
}

// AccountExists checks if the Account row exists.
func AccountExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"account\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if account exists")
	}

	return exists, nil
}
